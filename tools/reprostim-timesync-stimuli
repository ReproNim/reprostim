#!/usr/bin/env python3
# TODO: review https://psychopy.org/api/sound/playback.html and possibly use PTB's 
# facilities in PsychoPy for precise audio placement in time.
#
from time import time, sleep
t0 = time()

import logging
import glob
import sys
import os
import json
from datetime import datetime

# setup logging
logger = logging.getLogger(__name__)
handler = logging.StreamHandler(sys.stderr)
formatter = logging.Formatter('%(asctime)s [%(levelname)s] %(message)s')
handler.setFormatter(formatter)
logging.getLogger().addHandler(handler)
logger.setLevel(logging.DEBUG)
logger.info("reprostim-timesync-stimuli script started")

import qrcode
from psychopy import prefs
prefs.hardware['audioLib'] = ['ptb', 'pyo','pygame']
from psychopy import sound
from psychopy import visual, core, event, clock

import numpy as np

# 'interval'
mode = 'event'
interval = 2


# setup file JSON logger
logfn = sys.argv[1]
# logfn = "../data/{0}/run{1}_logfile.csv".format(acqNum, runNum)
if os.path.exists(logfn):
    logger.error(f"Log file {logfn} already exists")
    raise RuntimeError(f"Log file {logfn} already exists")


#######################################################
# Functions

def get_iso_time(t):
    return datetime.fromtimestamp(t).astimezone().isoformat()


def get_times():
    t = time()
    return t, get_iso_time(t)


def log(rec):
    f.write(json.dumps(rec).rstrip() + os.linesep)


def mkrec(**kwargs):
    t, tstr = get_times()
    kwargs.update({
        "logfn": logfn,
        "time": t,
        "time_formatted": tstr,
        "mode": mode,
    })
    if mode == 'interval':
        kwargs['interval'] = interval
    return kwargs


# Function to play a beep at a specific frequency and duration
def play_beep(frequency, duration, volume=1.0):
    logger.debug(f'play_beep({frequency}, duration={duration}, volume={volume})')
    # Create a sound object with the specified frequency
    beep = sound.Sound(frequency, secs=duration, volume=volume)
    beep.play()
    sound_time = get_times()
    core.wait(duration)  # Wait for the beep to finish
    return sound_time


def beep_4():
    logger.debug("beep_4()")

    #prefs.hardware['audioLib'] = ['sounddevice']
    prefs.hardware['audioLib'] = ['ptb']
    #prefs.hardware['audioDevice'] = 'HDA Intel PCH: ALC892 Digital (hw:0,1)'
    logger.debug("play sound with psychopy ptb")
    snd = sound.Sound('D', secs=120.0, stereo=True)
    #snd = sound.Sound('beep_003.wav')

    snd.play()
    core.wait(snd.duration)
    logger.debug(f'Sound "{snd.sound}" has finished playing.')


#######################################################
# Main script code

logger.info("main script started")
# print(json.dumps(mkrec(blah=123), indent=4))

f = open(logfn, "w")

win = visual.Window(fullscr=True, screen=int(sys.argv[2]))
win.mouseVisible = False # hides the mouse pointer 

log(mkrec(event="started", start_time=t0, start_time_formatted=get_iso_time(t0)))

message = visual.TextStim(win, text="""Waiting for scanner trigger.\nInstructions
        for Participant...""")
message.draw()

fixation = visual.TextStim(win, text='+')
reproinMessage = visual.TextStim(win, text="", pos=(0, -.7),
        height=.05)

win.flip()


fixation.draw()  # Change properties of existing stim
win.flip()

spd = 0.500 # Stimulus Presentation Duration
soa = 6.000 # Stimulus Onset Asynchrony
ntrials = 300
iwt = 5 # Initial Wait Time between scanner trigger and first stimulus

stim_images = []
stim_names = []
keys = []  # None received/expected

clk = clock.Clock()
t_start = time()

logger.debug(f"warming time: {(t_start-t0):.6f} sec")
#play_beep(480, 120, 1.0)
beep_4()
logger.debug(f"mode: {mode}, interval: {interval}")
logger.info(f"starting loop with {ntrials} trials...")



for acqNum in range(ntrials):
    logger.debug(f"trial {acqNum}")

    rec = mkrec(
        event="trigger",
        acqNum=acqNum
    )

    if mode == 'event':
        print("Waiting for an event")
        keys = event.waitKeys(maxWait=120) # keyList=['5'])
    elif mode == 'interval': 
        target_time = t_start + acqNum * interval
        to_wait = target_time - time()
        # sleep some part of it if long enough
        if to_wait >= .2:
            sleep(to_wait * 0.7)
        # busy loop without sleep to not miss it
        while time() < target_time:
            pass
    else:
        raise ValueError(mode)
   
    freq = 2000 + (100*acqNum)
    beep = sound.Sound(freq, secs=0.5, volume=0.8, sampleRate=44100, stereo=True)
    beep.play()
    rec['sound_time'] = get_times()
    rec['sound_freq'] = freq
    rec['keys'] = keys
    tkeys, tkeys_str = get_times()
    rec["keys_time"] = tkeys
    rec["keys_time_str"] = tkeys_str
    qr = visual.ImageStim(win,
                          qrcode.make(json.dumps(rec)),
                          pos=(0, 0)
                          )
    qr.size = qr.size *1 
    qr.draw()
    win.flip()
    tflip, tflip_str = get_times()
    rec['time_flip'] = tflip
    rec['time_flip_formatted'] = tflip_str
    core.wait(0.5)
    fixation.draw()
    win.flip()
    toff, toff_str = get_times()
    rec['prior_time_off'] = toff
    rec['prior_time_off_str'] = toff_str
    log(rec)
    if 'q' in keys:
        break

f.close()
logger.info("main script finished")
logger.info("reprostim-timesync-stimuli script finished")
